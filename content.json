{"meta":{"title":"东的博客","subtitle":"","description":"","author":"东","url":"http://example.com","root":"/"},"pages":[{"title":"我的博客","date":"2022-09-13T15:51:12.000Z","updated":"2022-09-13T15:51:12.896Z","comments":true,"path":"我的博客/index.html","permalink":"http://example.com/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-15T14:03:42.000Z","updated":"2022-09-15T14:04:12.286Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2022-09-15T13:53:14.000Z","updated":"2022-09-15T13:57:44.359Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-09-15T14:11:36.000Z","updated":"2022-09-15T14:16:03.185Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"邮箱: &#x7a;&#120;&#100;&#x6f;&#110;&#103;&#x31;&#50;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;"}],"posts":[{"title":"","slug":"关于读书的一点思考","date":"2023-05-05T09:46:00.624Z","updated":"2023-05-30T15:05:07.619Z","comments":true,"path":"2023/05/05/关于读书的一点思考/","link":"","permalink":"http://example.com/2023/05/05/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"","text":"关于读书的一点思考 1.为什么要读这本书？ 解决当前遇到的困惑，或者为以后的行动提供指导 2.如何读一本书？ 了解书中的背景（一般在序中），解决方案（观点，或者结论） 一、《影响力》 背景：生活中自己容易被说服做一些自己不想做的事情，比如买自己不想买的东西；有些人说服别人很厉害。 问题：有哪些因素在让一个人向另外一个人说“行”？哪些技术最有效地利用了这些因素，使人们产生了顺从心理？ 研究方法：参与式观察 结论：七大原则 二、《寻找内在自我：马斯洛谈幸福》 在心理学的发展中，马斯洛可以说是继弗洛伊德、荣格后的一位心理学大师。弗洛伊德抓住了潜意识从而给心理学带来了一场革命，不过“弗洛伊德将人类心理描绘成一种带有地下室的小屋，地下室中全是老鼠和腐烂的垃圾”。而马斯洛第一次清楚地阐明了人类有心理需要，包括对创造性，长远目标、价值观、善等的需要，从而创造了关于人性的一个完整视图。 马斯洛提出了“高峰体验”，是日常生活中的一部分。 马斯洛极具洞察力地提出，你是否有可能很幸福但不知道自己很幸福，答案的确是我们一直如此。当我们因为一些琐事而陷入困境的时候，如何能学会知觉到这一点呢？ 我一直认为人的问题可以很简单地进行表述：在面对有趣或令人激动的挑战时，我们就处在自己最好的状态。每个人都憧憬着更富有创造性、更富有成效的生活方式，而当外部问题都消失的时候，我们倾向于陷入一种停滞之中。 因此，我们追求某种“目标”来让自己获得满足，这个目标通常都是比较复杂但又很有趣的。 但找到这样既能让你感兴趣又基本上像是浪费生命的事情并不容易，比如你可以没完没了地办晚宴，邀请人来参加，直到你愿意自己一个人度过一个晚上。因此，人们发现面对的是一个对自己并没有什么帮助的选择：高高兴兴地被“卷入”，但又不得不承认浪费了大量的时间，或者不被“卷入”，但又被无聊所麻痹，缺乏目标。 对我来说，人性已经达到了进化的临界点，当前最迫切的需求是学会如何进入一种“着迷的状态”（心理卷入）并依然保持独处或没有让自己卷入其中。赫伯特·乔治·威尔斯（H.G.Wells）曾说过：“鱼是水的产物，鸟是天空的产物，人是思想的产物。”只有我们学会按照自己的意志随意进入这些“内在”状态的方法，这种意志才是真实的，否则我们依然会被外部世界所奴役。 如何让自己感受到幸福：关注高峰体验，并将它们看作生活正常且必要的组成部分，这就是获得高峰体验的窍门。 个人体会： 为什么要给自己设定目标，因为摆脱无聊的状态，追求“高峰体验”是人性的一部分。 三、《福格行为模型》 准确的说这是一篇关于怎么设计行为的书，将理论转为可操作的动作。 1.简单才能改变行动 我在商业领域工作时，会观察什么行得通、什么行不通。我看到了一个共同的模式，苹果和谷歌是这样的，所有成功的人都是这样的——他们创造了一个非常简单的产品。 2.行为公式 B&#x3D;MAP，即当“动机、能力、和提示”同时发生时，行为才能发生。 3.掌握微习惯策略，所有人都可以改变 四、《认知心理学》 认知心理学是以信息加工为核心的心理学，又可称作信息加工心理学，主要指以信息加工观点为特征的心理学。 五、《社会心理学》 揭示社会现象的心理学，包括科学家是怎么发现和解释这些现象的，同时激发学生思考，促使他们去探索，去分析，并把这些规则同日常生活联系起来。 六、《腾讯传》 问题1:为什么是腾讯，而不是其他互联网公司，成为当今中国市值最高、用户数最多、盈利能力最强的企业？它的成功是一次战略规划的结果，还是偶然的产物？ 问题2:为什么腾讯曾经遭遇空前的质疑，它所面临的模仿而不创新、封闭而不开放的“指控”是怎么形成的？性情温和的马化腾如何成为很多人眼中的“全民公敌”？ 问题3:中国互联网公司和美国互联网公司有什么异同？前者的繁荣是一次长期的追随之旅，还是有自己的东方式生存之道？ 成长四阶段理论：积累资源-&gt; 资源的合理化利用-&gt;持续增长-&gt;对扩展中的资源的合理利用 七种武器： 产品极简主义： 少就是合适的，“Don’t make me think” 用户驱动战略：马化腾提出互联网公司有三种驱动力，即技术驱动、应用驱动、用户和服务驱动，腾讯将着力对于第三种能力的培养。 内部赛马机制 试错迭代机制 生态养成模式 资本整合能力 专注创业初心 七、《增长黑客》 推荐序由迅雷创始人 程浩所做，其总结为以有限的资源获得最大限度的成长，以下为部分总结： “对于如何有效获取、留存用户、让业务爆发增长，书中不仅有体系的方法论，更有翔实的实战技巧。任何希望以有限的营销资源，甚至不想额外花钱就能收获的最大限度成长的企业家，本书都不容错过” 肖恩·埃利斯和摩根·布朗两位作者呕心撰写的《增长黑客》，可以说正是《精益创业》的姊妹篇。 因为《精益创业》主要聚焦在如何低成本快速验证需求和解决方案，所以埃里克并没有针对用户增长这块着更多笔墨，毕竟“由需求”是用户增长的前提。但是精益创业显然也不是万能钥匙，特别在国内，随着人口红利和移动互联网流量红利的双双消失，商业环境已完成了从以往粗放式增长到精细化运营的转变，初创企业即使验证了需求和方案，仍然面对如何获客和如何留存问题。而《增长黑客》主要讲的就是验证需求后，如何获客、如何激活、如何留存，以及如何赚取更多利润的方法。两本书相结合，基本覆盖了整个创业过程。 八、《精益创业》 铁匠在啤酒中洒下眼泪，悲叹自己没有办法在铁路时代卖马掌，但是这并不会使他们的马掌更受欢迎。哪些学习变成机械师的铁匠才会保住自己的饭碗。 企业唯有快速顺应时代才能赢得未来，产品生产方式必须因时代而改变 我们身处的商业时代有两大主题：互联网化和全球化。这个时代有几个新的特点：从市场结构来看，产品供给方的数量和质量远远超过了古典的商业时代，大多数市场是典型的买方市场，竞争激烈，企业唯有更好地满足客户需求才能生存；从消费趋势来看，用户的需求日趋多元化，满足他们需求的难度正在不断提高；从技术发展来看，以互联网、移动互联网为代表的信息技术，可以帮助企业深入理解大多数客户和消费者，按需驱动，使产品快速灵活地适应市场，同时去除无谓的损耗，企业效益得以最大化。 如何做？埃里克的《精益创业》作了一个优秀的提炼：目标顾客—小范围实验—反馈修改—产品迭代—获得核心认知—高速增长。 创业的第一阶段是把想法变成产品。这时开发的产品是精简的原型，投入最少的金钱和精力开发出体现核心价值的产品。 创业的第二阶段，新创企业要对正确的产品形态进行重点投入，做好做细，做“最了解用户的人”，做到极致 创业的第三阶段，成功者往往伴随着爆发式的增长，全面的扩张 九、小米创业思考","categories":[],"tags":[]},{"title":"Android资源简析","slug":"Android资源简析","date":"2023-04-16T04:02:08.000Z","updated":"2023-04-16T06:03:46.295Z","comments":true,"path":"2023/04/16/Android资源简析/","link":"","permalink":"http://example.com/2023/04/16/Android%E8%B5%84%E6%BA%90%E7%AE%80%E6%9E%90/","excerpt":"","text":"这里主要是对res目录下的几个重要类的源码做解读，加载机制可以参考 https://www.jianshu.com/p/817a787910f2 https://www.jianshu.com/p/02a2539890dc 觉得很不错。 ResourcesLoader 主要作用是添加额外的资源或者对已经存在的资源进行更改 12345private ApkAssets[] mApkAssets;private ResourcesProvider[] mPreviousProviders;private ResourcesProvider[] mProviders; 包含了以上几个重要属性，同时主要提供了这几个对象的get和set，clear方法 ResourcesProvider 负责从apk或者resources table加载资源数据 主要是通过loadFromXXX方法从apk，table或者Directory加载数据，而loadFromXXX方法则进一步调用了ApkAssets相关方法，最终通过对应的native方法来加载资源 AssetManager","categories":[],"tags":[]},{"title":"ActivityInfo杂记","slug":"ActivityInfo杂记","date":"2023-04-16T02:42:13.000Z","updated":"2023-04-16T04:02:14.677Z","comments":true,"path":"2023/04/16/ActivityInfo杂记/","link":"","permalink":"http://example.com/2023/04/16/ActivityInfo%E6%9D%82%E8%AE%B0/","excerpt":"","text":"ActivityInfo 提供了某个Activity或者receiver的信息，相关信息从manifest中解析而来 ApplicationInfo 解析manifest中的application标签生成，包括像taskAffinity,permission,processName等信息 Packageinfo 包的全部信息，包含了所有从manifest解析而来的内容，比如四大组件信息，签名信息，apk和splitApk名称等。","categories":[],"tags":[]},{"title":"DownloadManager简析","slug":"DownloadManager简析","date":"2023-04-15T08:29:19.000Z","updated":"2023-04-16T02:39:43.184Z","comments":true,"path":"2023/04/15/DownloadManager简析/","link":"","permalink":"http://example.com/2023/04/15/DownloadManager%E7%AE%80%E6%9E%90/","excerpt":"","text":"DownloadManger是用于处理长时间运行http下载的系统服务，downlaodermanager可以运行在后台，同时对失败情况进行retry处理。需要INTERNET 权限。 DownloadManager只是提供给开发者的一个外部调用接口，真正的具体管理要看下载服务管理 http://aospxref.com/android-13.0.0_r3/xref/packages/providers/DownloadProvider/ 主要是将请求信息插入数据库，再由下载管理进行具体的下载操作，暂时就不做多分析 参考： https://blog.csdn.net/garment1991/article/details/54178557/","categories":[],"tags":[]},{"title":"ActivityManager简要分析","slug":"ActivityManager简要分析","date":"2023-04-15T07:28:23.000Z","updated":"2023-04-15T08:11:20.877Z","comments":true,"path":"2023/04/15/ActivityManager简要分析/","link":"","permalink":"http://example.com/2023/04/15/ActivityManager%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/","excerpt":"","text":"ActivityManager提供了关于Activity，Service信息，大多数场景下不需要使用，但是其中也提供了几个重要的方法，比如isLowRamDevice，判读是否运行在一个低内存手机上，或者clearApplicationUserData 重置应用数据。 如果应用需要同Task stack打交道，也可能会用到其中的ActivityManager.AppTask和ActivityManager.RecentTaskInfo,另外还涉及到一些进程相关的api ActivityManager交互的对象很多，比如像最近任务、进程、服务等等。 Task相关 获取应用的任务信息 123456789101112131415161718192021/** * Get the list of tasks associated with the calling application. * * @return The list of tasks associated with the application making this call. * @throws SecurityException */public List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123; ArrayList&lt;AppTask&gt; tasks = new ArrayList&lt;AppTask&gt;(); List&lt;IBinder&gt; appTasks; try &#123; appTasks = getTaskService().getAppTasks(mContext.getOpPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; int numAppTasks = appTasks.size(); for (int i = 0; i &lt; numAppTasks; i++) &#123; tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i)))); &#125; return tasks;&#125; 添加任务 1234567891011 /* Add a new ActivityManager.AppTask for the calling application. This will create a new recents entry that is added to the end of all existing recents.Params:activity – The activity that is adding the entry. This is used to help determine the context that the new recents entry will be in.intent – The Intent that describes the recents entry. This is the same Intent that you would have used to launch the activity for it. In generally you will want to set both Intent.FLAG_ACTIVITY_NEW_DOCUMENT and Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS; the latter is required since this recents entry will exist without an activity, so it doesn&#x27;t make sense to not retain it when its activity disappears. The given Intent here also must have an explicit ComponentName set on it.description – Optional additional description information.thumbnail – Thumbnail to use for the recents entry. Should be the size given by getAppTaskThumbnailSize(). If the bitmap is not that exact size, it will be recreated in your process, probably in a way you don&#x27;t like, before the recents entry is added.Returns:Returns the task id of the newly added app task, or -1 if the add failed. The most likely cause of failure is that there is no more room for more tasks for your app.*/ public int addAppTask(@NonNull Activity activity, @NonNull Intent intent, @Nullable TaskDescription description, @NonNull Bitmap thumbnail) 移动任务 123public void moveTaskToFront(int taskId, @MoveTaskFlags int flags) &#123; moveTaskToFront(taskId, flags, null);&#125; 服务相关 获取运行时服务 123456789public List&lt;RunningServiceInfo&gt; getRunningServices(int maxNum) throws SecurityException &#123; try &#123; return getService() .getServices(maxNum, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 内存管理相关 定义了内部类MemoryInfo,主要属性如下 123456789101112131415161718192021222324252627282930public static class MemoryInfo implements Parcelable &#123; /** * The available memory on the system. This number should not * be considered absolute: due to the nature of the kernel, a significant * portion of this memory is actually in use and needed for the overall * system to run well. */ public long availMem; /** * The total memory accessible by the kernel. This is basically the * RAM size of the device, not including below-kernel fixed allocations * like DMA buffers, RAM for the baseband CPU, etc. */ public long totalMem; /** * The threshold of &#123;@link #availMem&#125; at which we consider memory to be * low and start killing background services and other non-extraneous * processes. */ public long threshold; /** * Set to true if the system considers itself to currently be in a low * memory situation. */ public boolean lowMemory; //... ...&#125; 因此可以获取内存相关的信息 1234567public void getMemoryInfo(MemoryInfo outInfo) &#123; try &#123; getService().getMemoryInfo(outInfo); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 进程异常状态监控 内部类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Information you can retrieve about any processes that are in an error condition. */public static class ProcessErrorStateInfo implements Parcelable &#123; public int condition; /** * The process name in which the crash or error occurred. */ public String processName; /** * The pid of this process; 0 if none */ public int pid; /** * The kernel user-ID that has been assigned to this process; * currently this is not a unique ID (multiple applications can have * the same uid). */ public int uid; /** * The activity name associated with the error, if known. May be null. */ public String tag; /** * A short message describing the error condition. */ public String shortMsg; /** * A long message describing the error condition. */ public String longMsg; /** * The stack trace where the error originated. May be null. */ public String stackTrace; /** * to be deprecated: This value will always be null. */ public byte[] crashData = null; &#125; 可见其中的crashData是我们重点关注的数据 调用方法 1234567public List&lt;ProcessErrorStateInfo&gt; getProcessesInErrorState() &#123; try &#123; return getService().getProcessesInErrorState(); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 运行时进程相关 内部类 12345678910111213141516171819public static class RunningAppProcessInfo implements Parcelable &#123; public String processName; /** * The pid of this process; 0 if none */ public int pid; /** * The user id of this process. */ public int uid; /** * All packages that have been loaded into the process. */ public String pkgList[]; //... ...&#125; 设置内存level 12345678public boolean setProcessMemoryTrimLevel(String process, int userId, int level) &#123; try &#123; return getService().setProcessMemoryTrimLevel(process, userId, level); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 获取运行时进程 1234567public List&lt;RunningAppProcessInfo&gt; getRunningAppProcesses() &#123; try &#123; return getService().getRunningAppProcesses(); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 获取进程状态 1234567public int getUidProcessState(int uid) &#123; try &#123; return getService().getUidProcessState(uid, mContext.getOpPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 获取进程状态信息 1234567public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids) &#123; try &#123; return getService().getProcessMemoryInfo(pids); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; 杀死后台进程 12345678public void killBackgroundProcesses(String packageName) &#123; try &#123; getService().killBackgroundProcesses(packageName, mContext.getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125;","categories":[],"tags":[]},{"title":"Activity分析","slug":"Activity分析","date":"2023-04-15T02:52:17.000Z","updated":"2023-04-15T06:07:36.508Z","comments":true,"path":"2023/04/15/Activity分析/","link":"","permalink":"http://example.com/2023/04/15/Activity%E5%88%86%E6%9E%90/","excerpt":"","text":"Activity作为四大组件之一，其重要性不言而喻。但是之前对于Activity的了解也只是限于生命周期，启动流程等过程，比较零散，没有系统的整理。 123456public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, AutofillManager.AutofillClient, ContentCaptureManager.ContentCaptureClient 从继承和实现关系上看，Activity继承自ContextThemeWrapper，同时实现了以下几个接口，从接口名称上大致可以判断，Activity还要和View，Window，KeyEvent等进行交互。所以也不仅仅是限于生命周期管理这么简单。 下面是一些重要的属性 12345678910111213141516171819202122private Instrumentation mInstrumentation;private IBinder mToken;private IBinder mShareableActivityToken;private Application mApplication;/*package*/ Intent mIntent;private ComponentName mComponent;/*package*/ ActivityInfo mActivityInfo;/*package*/ ActivityThread mMainThread;private final ArrayList&lt;Application.ActivityLifecycleCallbacks&gt; mActivityLifecycleCallbacks = new ArrayList&lt;Application.ActivityLifecycleCallbacks&gt;();private Window mWindow;private WindowManager mWindowManager;/*package*/ View mDecor = null;final Handler mHandler = new Handler();final FragmentController mFragments = FragmentController.createController(new HostCallbacks());private Thread mUiThread;private SplashScreen mSplashScreen; 可以看到Activity很忙，跟它交互的对象有很多。一个个看 mInstrumentation 在代码中搜索它的作用只不过是对Activity的一些生命周期操作进行转发，如 12345678public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; //... mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); //... &#125; 它的初始化则是在attach方法中注入。attach其实就是负责完成了Activity中的属性的初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mAssistToken = assistToken; mShareableActivityToken = shareableActivityToken; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; //... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode); mWindow.setPreferMinimalPostProcessing( (info.flags &amp; ActivityInfo.FLAG_PREFER_MINIMAL_POST_PROCESSING) != 0); setAutofillOptions(application.getAutofillOptions()); setContentCaptureOptions(application.getContentCaptureOptions()); &#125; 熟悉Activity启动的话就会知道Activity的attach方法是在ActivityThread的 performLaunchActivity中调用的，初始化的内容比较多，想说的就是除了mWindow和mUiThread实在本地new出来的，其他的都是外部注入的，因此外部注入的对象可以只分析在当前对象中的作用，完整的功能机制后面在做分析。 mToken mToken是一个IBinder对象，Activity中没有调用其方法，只是把它作为一个参数传来传去，但是随便跟踪一个方法，然后找到mToken具体调用的地方，会发现，mToken其实是一个ActivityRecord 对象 123456789private static class Token extends Binder &#123; @NonNull WeakReference&lt;ActivityRecord&gt; mActivityRef; @Override public String toString() &#123; return &quot;Token&#123;&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot; &quot; + mActivityRef.get() + &quot;&#125;&quot;; &#125;&#125; 持有ActivityRecord的弱引用，因此也可以说他其实是一个ActiviytRecord对象。 mShareableActivityToken 也是ActivityRecord中的一个属性，尚不清楚具体作用 mApplication mApplication不用多说，获取应用程序相关的信息 mIntent 当前Activity相关的intent mActivityInfo ActivityInfo类型对象，跟Activity一一对应 mMainThread ActivityThead类型，ActivityThead是应用程序的main thread，在Activity中调用了两个方法 getApplicationThread ： 返回的是一个IBinder对象，用于跨进程通信 ​ sendActivityResult： 发送结果给Activity，onActivityResult会被调用 mActivityLifecycleCallbacks 主要跟Lifecycler结合使用，在生命周期改变时调用dispatchActivityXXX来完成相关接口的分发 mWindow，mWindowManager 每个activity对应着一个窗口 mDecor 视图的根view mFragments 生命周期变化时调用相关的Framgent方法，完成Fragment的生命周期调用 mUiThread 当前Activity的运行线程，用来做主线程判断 mSplashScreen 跟闪屏进行交互 以上便是Actvity中的一些重要对象，Activity的行为都跟他们息息相关。从面相对象的角度思考，清楚了Activity的交互对象，那么Activity的行为大致也就了解了，比如跟instrumentaion交互管理activity的启动，跟winow交互管理对应的窗口，也可以同SplashScreen交互，或者管理Framgent的启动等。","categories":[],"tags":[]},{"title":"Android包结构分析","slug":"Android包分析","date":"2023-04-15T02:52:17.000Z","updated":"2023-04-15T08:28:08.689Z","comments":true,"path":"2023/04/15/Android包分析/","link":"","permalink":"http://example.com/2023/04/15/Android%E5%8C%85%E5%88%86%E6%9E%90/","excerpt":"","text":"好比用java的要熟悉jdk，Android的jar包也是需要深入了解，才能在宏观上有所把握。 android - app - content - service - View dalvik system 以上几个包的内容都是目前需要重点掌握的，后面的源码分析也按照这个顺序为主","categories":[],"tags":[]},{"title":"杂记（1）","slug":"杂记（1）","date":"2023-04-05T06:58:02.000Z","updated":"2023-04-15T02:52:23.941Z","comments":true,"path":"2023/04/05/杂记（1）/","link":"","permalink":"http://example.com/2023/04/05/%E6%9D%82%E8%AE%B0%EF%BC%881%EF%BC%89/","excerpt":"","text":"不注重研究现状，不注重研究历史，不注重马克思列宁主义的应用，这些都是极坏的作风。 ​ 出自《改造我们的学习》毛泽东 了解过去，掌握规律，把握当下。无忧无虑的幻想总是轻松自在的，而面对现实的时候则总是耗费精力的，这也是为什么会感到疲惫。","categories":[],"tags":[]}],"categories":[],"tags":[]}