{"meta":{"title":"东的博客","subtitle":"","description":"","author":"东","url":"http://example.com","root":"/"},"pages":[{"title":"我的博客","date":"2022-09-13T15:51:12.000Z","updated":"2022-09-13T15:51:12.896Z","comments":true,"path":"我的博客/index.html","permalink":"http://example.com/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2022-09-15T13:53:14.000Z","updated":"2022-09-15T13:57:44.359Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-15T14:03:42.000Z","updated":"2022-09-15T14:04:12.286Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-09-15T14:11:36.000Z","updated":"2022-09-15T14:16:03.185Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"邮箱: &#122;&#120;&#100;&#x6f;&#x6e;&#103;&#x31;&#x32;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;"}],"posts":[{"title":"ActivityManager简要分析","slug":"ActivityManager简要分析","date":"2023-04-15T07:28:23.000Z","updated":"2023-04-15T08:11:20.877Z","comments":true,"path":"2023/04/15/ActivityManager简要分析/","link":"","permalink":"http://example.com/2023/04/15/ActivityManager%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/","excerpt":"","text":"ActivityManager提供了关于Activity，Service信息，大多数场景下不需要使用，但是其中也提供了几个重要的方法，比如isLowRamDevice，判读是否运行在一个低内存手机上，或者clearApplicationUserData 重置应用数据。 如果应用需要同Task stack打交道，也可能会用到其中的ActivityManager.AppTask和ActivityManager.RecentTaskInfo,另外还涉及到一些进程相关的api ActivityManager交互的对象很多，比如像最近任务、进程、服务等等。 Task相关 获取应用的任务信息 123456789101112131415161718192021/** * Get the list of tasks associated with the calling application. * * @return The list of tasks associated with the application making this call. * @throws SecurityException */public List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123; ArrayList&lt;AppTask&gt; tasks = new ArrayList&lt;AppTask&gt;(); List&lt;IBinder&gt; appTasks; try &#123; appTasks = getTaskService().getAppTasks(mContext.getOpPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; int numAppTasks = appTasks.size(); for (int i = 0; i &lt; numAppTasks; i++) &#123; tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i)))); &#125; return tasks;&#125; 添加任务 1234567891011 /* Add a new ActivityManager.AppTask for the calling application. This will create a new recents entry that is added to the end of all existing recents.Params:activity – The activity that is adding the entry. This is used to help determine the context that the new recents entry will be in.intent – The Intent that describes the recents entry. This is the same Intent that you would have used to launch the activity for it. In generally you will want to set both Intent.FLAG_ACTIVITY_NEW_DOCUMENT and Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS; the latter is required since this recents entry will exist without an activity, so it doesn&#x27;t make sense to not retain it when its activity disappears. The given Intent here also must have an explicit ComponentName set on it.description – Optional additional description information.thumbnail – Thumbnail to use for the recents entry. Should be the size given by getAppTaskThumbnailSize(). If the bitmap is not that exact size, it will be recreated in your process, probably in a way you don&#x27;t like, before the recents entry is added.Returns:Returns the task id of the newly added app task, or -1 if the add failed. The most likely cause of failure is that there is no more room for more tasks for your app.*/ public int addAppTask(@NonNull Activity activity, @NonNull Intent intent, @Nullable TaskDescription description, @NonNull Bitmap thumbnail) 移动任务 123public void moveTaskToFront(int taskId, @MoveTaskFlags int flags) &#123; moveTaskToFront(taskId, flags, null);&#125; 服务相关 获取运行时服务 123456789public List&lt;RunningServiceInfo&gt; getRunningServices(int maxNum) throws SecurityException &#123; try &#123; return getService() .getServices(maxNum, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 内存管理相关 定义了内部类MemoryInfo,主要属性如下 123456789101112131415161718192021222324252627282930public static class MemoryInfo implements Parcelable &#123; /** * The available memory on the system. This number should not * be considered absolute: due to the nature of the kernel, a significant * portion of this memory is actually in use and needed for the overall * system to run well. */ public long availMem; /** * The total memory accessible by the kernel. This is basically the * RAM size of the device, not including below-kernel fixed allocations * like DMA buffers, RAM for the baseband CPU, etc. */ public long totalMem; /** * The threshold of &#123;@link #availMem&#125; at which we consider memory to be * low and start killing background services and other non-extraneous * processes. */ public long threshold; /** * Set to true if the system considers itself to currently be in a low * memory situation. */ public boolean lowMemory; //... ...&#125; 因此可以获取内存相关的信息 1234567public void getMemoryInfo(MemoryInfo outInfo) &#123; try &#123; getService().getMemoryInfo(outInfo); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 进程异常状态监控 内部类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Information you can retrieve about any processes that are in an error condition. */public static class ProcessErrorStateInfo implements Parcelable &#123; public int condition; /** * The process name in which the crash or error occurred. */ public String processName; /** * The pid of this process; 0 if none */ public int pid; /** * The kernel user-ID that has been assigned to this process; * currently this is not a unique ID (multiple applications can have * the same uid). */ public int uid; /** * The activity name associated with the error, if known. May be null. */ public String tag; /** * A short message describing the error condition. */ public String shortMsg; /** * A long message describing the error condition. */ public String longMsg; /** * The stack trace where the error originated. May be null. */ public String stackTrace; /** * to be deprecated: This value will always be null. */ public byte[] crashData = null; &#125; 可见其中的crashData是我们重点关注的数据 调用方法 1234567public List&lt;ProcessErrorStateInfo&gt; getProcessesInErrorState() &#123; try &#123; return getService().getProcessesInErrorState(); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 运行时进程相关 内部类 12345678910111213141516171819public static class RunningAppProcessInfo implements Parcelable &#123; public String processName; /** * The pid of this process; 0 if none */ public int pid; /** * The user id of this process. */ public int uid; /** * All packages that have been loaded into the process. */ public String pkgList[]; //... ...&#125; 设置内存level 12345678public boolean setProcessMemoryTrimLevel(String process, int userId, int level) &#123; try &#123; return getService().setProcessMemoryTrimLevel(process, userId, level); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 获取运行时进程 1234567public List&lt;RunningAppProcessInfo&gt; getRunningAppProcesses() &#123; try &#123; return getService().getRunningAppProcesses(); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 获取进程状态 1234567public int getUidProcessState(int uid) &#123; try &#123; return getService().getUidProcessState(uid, mContext.getOpPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 获取进程状态信息 1234567public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids) &#123; try &#123; return getService().getProcessMemoryInfo(pids); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; 杀死后台进程 12345678public void killBackgroundProcesses(String packageName) &#123; try &#123; getService().killBackgroundProcesses(packageName, mContext.getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125;","categories":[],"tags":[]},{"title":"Android包结构分析","slug":"Android包分析","date":"2023-04-15T02:52:17.000Z","updated":"2023-04-15T07:28:31.028Z","comments":true,"path":"2023/04/15/Android包分析/","link":"","permalink":"http://example.com/2023/04/15/Android%E5%8C%85%E5%88%86%E6%9E%90/","excerpt":"","text":"好比用java的要熟悉jdk，Android的jar包也是需要深入了解，才能在宏观上有所把握。 android - app - content - service - View dalvik system 以上几个包的内容都是目前需要重点掌握的，后面的源码分析也按照这个顺序为主","categories":[],"tags":[]},{"title":"Activity分析","slug":"Activity分析","date":"2023-04-15T02:52:17.000Z","updated":"2023-04-15T06:07:36.508Z","comments":true,"path":"2023/04/15/Activity分析/","link":"","permalink":"http://example.com/2023/04/15/Activity%E5%88%86%E6%9E%90/","excerpt":"","text":"Activity作为四大组件之一，其重要性不言而喻。但是之前对于Activity的了解也只是限于生命周期，启动流程等过程，比较零散，没有系统的整理。 123456public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, AutofillManager.AutofillClient, ContentCaptureManager.ContentCaptureClient 从继承和实现关系上看，Activity继承自ContextThemeWrapper，同时实现了以下几个接口，从接口名称上大致可以判断，Activity还要和View，Window，KeyEvent等进行交互。所以也不仅仅是限于生命周期管理这么简单。 下面是一些重要的属性 12345678910111213141516171819202122private Instrumentation mInstrumentation;private IBinder mToken;private IBinder mShareableActivityToken;private Application mApplication;/*package*/ Intent mIntent;private ComponentName mComponent;/*package*/ ActivityInfo mActivityInfo;/*package*/ ActivityThread mMainThread;private final ArrayList&lt;Application.ActivityLifecycleCallbacks&gt; mActivityLifecycleCallbacks = new ArrayList&lt;Application.ActivityLifecycleCallbacks&gt;();private Window mWindow;private WindowManager mWindowManager;/*package*/ View mDecor = null;final Handler mHandler = new Handler();final FragmentController mFragments = FragmentController.createController(new HostCallbacks());private Thread mUiThread;private SplashScreen mSplashScreen; 可以看到Activity很忙，跟它交互的对象有很多。一个个看 mInstrumentation 在代码中搜索它的作用只不过是对Activity的一些生命周期操作进行转发，如 12345678public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; //... mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); //... &#125; 它的初始化则是在attach方法中注入。attach其实就是负责完成了Activity中的属性的初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mAssistToken = assistToken; mShareableActivityToken = shareableActivityToken; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; //... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode); mWindow.setPreferMinimalPostProcessing( (info.flags &amp; ActivityInfo.FLAG_PREFER_MINIMAL_POST_PROCESSING) != 0); setAutofillOptions(application.getAutofillOptions()); setContentCaptureOptions(application.getContentCaptureOptions()); &#125; 熟悉Activity启动的话就会知道Activity的attach方法是在ActivityThread的 performLaunchActivity中调用的，初始化的内容比较多，想说的就是除了mWindow和mUiThread实在本地new出来的，其他的都是外部注入的，因此外部注入的对象可以只分析在当前对象中的作用，完整的功能机制后面在做分析。 mToken mToken是一个IBinder对象，Activity中没有调用其方法，只是把它作为一个参数传来传去，但是随便跟踪一个方法，然后找到mToken具体调用的地方，会发现，mToken其实是一个ActivityRecord 对象 123456789private static class Token extends Binder &#123; @NonNull WeakReference&lt;ActivityRecord&gt; mActivityRef; @Override public String toString() &#123; return &quot;Token&#123;&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot; &quot; + mActivityRef.get() + &quot;&#125;&quot;; &#125;&#125; 持有ActivityRecord的弱引用，因此也可以说他其实是一个ActiviytRecord对象。 mShareableActivityToken 也是ActivityRecord中的一个属性，尚不清楚具体作用 mApplication mApplication不用多说，获取应用程序相关的信息 mIntent 当前Activity相关的intent mActivityInfo ActivityInfo类型对象，跟Activity一一对应 mMainThread ActivityThead类型，ActivityThead是应用程序的main thread，在Activity中调用了两个方法 getApplicationThread ： 返回的是一个IBinder对象，用于跨进程通信 ​ sendActivityResult： 发送结果给Activity，onActivityResult会被调用 mActivityLifecycleCallbacks 主要跟Lifecycler结合使用，在生命周期改变时调用dispatchActivityXXX来完成相关接口的分发 mWindow，mWindowManager 每个activity对应着一个窗口 mDecor 视图的根view mFragments 生命周期变化时调用相关的Framgent方法，完成Fragment的生命周期调用 mUiThread 当前Activity的运行线程，用来做主线程判断 mSplashScreen 跟闪屏进行交互 以上便是Actvity中的一些重要对象，Activity的行为都跟他们息息相关。从面相对象的角度思考，清楚了Activity的交互对象，那么Activity的行为大致也就了解了，比如跟instrumentaion交互管理activity的启动，跟winow交互管理对应的窗口，也可以同SplashScreen交互，或者管理Framgent的启动等。","categories":[],"tags":[]},{"title":"杂记（1）","slug":"杂记（1）","date":"2023-04-05T06:58:02.000Z","updated":"2023-04-15T02:52:23.941Z","comments":true,"path":"2023/04/05/杂记（1）/","link":"","permalink":"http://example.com/2023/04/05/%E6%9D%82%E8%AE%B0%EF%BC%881%EF%BC%89/","excerpt":"","text":"不注重研究现状，不注重研究历史，不注重马克思列宁主义的应用，这些都是极坏的作风。 ​ 出自《改造我们的学习》毛泽东 了解过去，掌握规律，把握当下。无忧无虑的幻想总是轻松自在的，而面对现实的时候则总是耗费精力的，这也是为什么会感到疲惫。","categories":[],"tags":[]}],"categories":[],"tags":[]}